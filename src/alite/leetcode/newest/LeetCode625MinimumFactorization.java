package alite.leetcode.newest;
/**
 * LeetCode 625 - Minimum Factorization

https://leetcode.com/problems/minimum-factorization
Given a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a.
If there is no answer or the answer is not fit in 32-bit signed integer, then return 0.
Example 1
Input:
48 
Output:
68
Example 2
Input:
15
Output:
35
Approach #3 Using Factorization
We know that the final number generated, resres, should be such that its digits should have a product equal to the given number aa. In other words, the digits of resres will be the factors of the given number aa. Thus, our problem reduces to finding the factors(not necessarily prime) of aa and finding their smallest possible arrangement. Thus, we start with trying with the largest possible factor 99, obtain as many such counts of this factor as possible in resres and place such factors obtianed at its least significant positions. Then, we go on decrementing the number currently considered as the possible factor and if it is a factor, we keep on placing it at relatively more significant positions in resres. We go on getting such factors till we are done considering all the numbers from 9 to 2. At the end, resres gives the required resul
Time complexity : O(8loga)O(8loga). Outer loop will iterate only 8 times, while inner loop takes O(logi)O(logi) for particular ii.
    public int smallestFactorization(int a) {
        if (a < 2)
            return a;
        long res = 0, mul = 1;
        for (int i = 9; i >= 2; i--) {
            while (a % i == 0) {
                a /= i;
                res = mul * i + res;
                mul *= 10;
            }
        }
        return a < 2 && res <= Integer.MAX_VALUE ? (int)res : 0;
    }
http://www.geeksforgeeks.org/find-smallest-number-whose-digits-multiply-given-number-n/
https://discuss.leetcode.com/topic/92854/java-solution-result-array/
    public int smallestFactorization(int n) {
        // Case 1: If number is smaller than 10
        if (n < 10) return n;
        
        // Case 2: Start with 9 and try every possible digit
        List<Integer> res = new ArrayList<>();
        for (int i = 9; i > 1; i--) {
            // If current digit divides n, then store all
            // occurrences of current digit in res
            while (n % i == 0) {
                n = n / i;
                res.add(i);
            }
        }

        // If n could not be broken in form of digits
        if (n != 1) return 0;

        // Get the result from the array in reverse order
        long result = 0;
        for (int i = res.size() - 1; i >= 0; i--) {
            result = result * 10 + res.get(i);
            if (result > Integer.MAX_VALUE) return 0;
        }
        
        return (int)result;
    }
int smallestFactorization(int a) {
    if (a < 10) return a;
    long res = 0;
    for (long i = 9, f = 1; i > 1; i--)
        while (a % i == 0) {
            res += i * f;
            if (res > INT_MAX) return 0;
            a /= i;
            f *= 10;
        }
    return a == 1 ? res : 0;
}
Instead of considering every possible number from the total search space, we can do the search in a smarter way. We can start putting the numbers from 9 to 2 at the ones position and keep on proceeding towards more significant places. For every number currently generated, we can check if the product of its digits exceeds the given number aa. If so, there is no point in appending more digitas to this number. Thus, we can change the composition of the number generated till now and continue the checking process.
For doing this, we make use of a recursive function search(), which takes the number generated till now, resres(as a string) as one of its arguments along with the number to be appended next as the resres as a prefix as one of the other arguments. We can note that to obtain the smallest possible number, we need to try to put the largest number(which will be one of the factors for constituting the product aa) at the least significant position and the smallest one at the most significant position. Thus, we start from the least significant position by trying to place a 9 at this position and then continue by trying to place smaller numbers at this position if the numbers generated by the previous arrangements fail. If some arrangement leads to a product of digits not larger than aa, we continue with placing digits, equal to or smaller than the last digit placed, at the more significant positions.
Time complexity : O(l)O(l). Here ll refers to total number of combinations.
Space complexity : O(log(a))O(log(a)). In worst case, depth of recursion tree can go upto the O(log(a))O(log(a)) .
    long ans;
    public int smallestFactorization(int a) {
        if(a < 2)
            return a;
        int[] dig=new int[]{9, 8, 7, 6, 5, 4, 3, 2};
        if (search(dig, 0, a, 1, "") && ans <= Integer.MAX_VALUE)
            return (int)ans;
        return 0;
    }
    public boolean search(int[] dig, int i, int a, long mul, String res) {
        if (mul > a || i == dig.length )
            return false;
        if (mul == a) {
            ans = Long.parseLong(res);
            return true;
        }
        return search(dig, i, a, mul * dig[i], dig[i] + res) || search(dig, i + 1, a, mul, res);
    }

The simplest solution is to consider every possible 32-bit number starting from 1 which satisfies the given criteria. To check this, we obtain each individual digit of every such number and check if their product is equal to the given number aa. As soon as such a number is found, we return the same. If no such 32-bit number is found, we return a 0 value.
Time complexity : O(9999999999)O(9999999999). In case of prime numbers loop can go upto this large number.
    public int smallestFactorization(int a) {
        for (int i = 1; i < 999999999; i++) {
            long mul = 1, t = i;
            while (t != 0) {
                mul *= t % 10;
                t /= 10;
            }
            if (mul == a && mul <= Integer.MAX_VALUE)
                return i;
        }
        return 0;
    }
 * @author het
 *
 */
public class LeetCode625MinimumFactorization {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
